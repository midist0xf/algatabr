{
  "ABR": {
    "DescrizioneLezione": "Ciao in questa lezione vedremo le operazioni base di un albero binario di ricerca",
    "AlgoritmoInterattivo": "ABR",
    "Pseudocodice": {
      "Tree lookup(Tree t, Int j)": "while (t != null && t.key != j)\n\tif (j < t.key)\n\t\tt = t.left\n\telse\n\t\tt = t.right\nreturn t",
      "Void link(Tree p, Tree u, Int j)": "if (u != null)\n\tu.parent = p\nif (p != null)\n\tif (j < p.key)\n\t\tp.left = u\n\telse\n\t\tp.right = u",
      "Void insertNode(Tree t, Int j, Int v)": "Tree p = null\nTree u = t\nwhile(u != null && u.key != j)\n\tp = u\n\tif (j < u.key)\n\t\tu = u.left\n\telse\n\t\tu = u.right\n\nif (u != null && u.key == j)\n\tu.value = v\nelse\n\tTree n = new Tree(j, v)\n\tlink(p,n,j)",
      "Tree removeNode(Int x, Tree r)": "Tree u = lookup(r,x)\nif (u != null)\n   if(u.left != null && u.right != null)\n      Tree s = u.right\n      while (s.left != null)\n         s = s.left\n      u.key = s.key\n      u.value = s.value\n      x = s.key\n      u = s\n\n    Tree t\n    if (u.left != null && u.right == null)\n       t = u.left\n    else\n       t = u.right\n\n    link(u.parent, t, x)\n    if (u.parent == null)\n       if (t != null)\n          t.parent = null\n       return t\nreturn r",
      "Tree min(Tree t)": "while (t.left != null)\n\tt = t.left\nreturn t",
      "Tree max(Tree t)": "while (t.right != null)\n\tt = t.right\nreturn t",
      "Tree successorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.right != null)\n\treturn t.right.min\n\nTree p = t.parent\nwhile (p != null && t == p.right)\n\tt = p\n\tp = p.parent\n\nreturn p",
      "Tree predecessorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.left != null)\n\treturn t.right.max\n\nTree p = t.parent\nwhile (p != null && t == p.left)\n\tt = p\n\tp = p.parent\n\nreturn p"
    },
    "DomandeRiposteSpiegazioni": {
      "Che proprietà verificano gli ABR?": [
        "Le chiavi nel sottoalbero sx sono minori della chiave in u e le chiavi nel sottoalbero dx sono maggiori della chiave in u",
        "Risposta corretta",
        "Le chiavi nel sottoalbero dx sono minori della chiave in u e le chiavi nel sottoalbero sx sono maggiori della chiave in u",
        "Risposta sbagliata, perchè è vero il viceversa",
        "Le chiavi nel sottoalbero sx sono minori o uguali della chiave in u e le chiavi nel sottoalbero dx sono maggiori della chiave in u",
        "Risposta sbagliata, perchè le chiavi contenute\nnel sottoalbero sx sono strettamente minori\ndella chiave contenuta in u"
      ],
      "Quanto costa la procedura lookupNode?": [
        "O(h), dove h è l'altezza dell'albero",
        "Risposta corretta",
        "O(1)",
        "Risposta sbagliata, costa O(h), dove h è\nl'altezza dell'albero",
        "O(n) dove n è il numero dei nodi",
        "Risposta sbagliata, costa O(h), dove h è\nl'altezza dell'albero"
      ],
      "Quanti casi deve gestire la removeNode?": [
        "Tre: u non ha figli, u ha un solo figlio, u ha due figli",
        "Risposta corretta",
        "Quattro: u non ha figli, u ha un solo figlio, u ha due figli diversi, u ha due figli uguali",
        "Risposta sbagliata, perchè non è possibile\nche un nodo abbia due figli uguali",
        "Due: u non ha figli, u ha un solo figlio",
        "Risposta sbagliata, perchè manca il caso nel quale\nun nodo abbia due figli"
      ],
      "Salvato il minimo di T in u, si itera sul successore di u fino a quando questo non è null. Quanto costa questa procedura?": [
        "O(n) in quanto tutti i nodi vengono visitati al massimo due volte",
        "Risposta corretta",
        "O(n) in quanto tutti i nodi vengono visitati al massimo una volta",
        "Risposta sbagliata, perchè i nodi vengono visitati\nal massimo due volte, una volta per cercare\nil minimo e una volta per cercare il successore",
        "O(n) in quanto tutti i nodi vengono visitati al massimo quattro volte",
        "Risposta sbagliata, perchè i nodi vengono visitati\nal massimo due volte, una volta per cercare\nil minimo e una volta per cercare il successore"
      ],
      "Quale di queste caratteristiche di un ABR è vera?": [
        "Il costo di lookupNode, insertNode e removeNode può essere O(n) nel caso pessimo",
        "Risposta corretta, perchè l'albero può allungarsi\ninserendo e cancellando nodi",
        "Il costo di lookupNode, insertNode e removeNode è sempre O(log n)",
        "Risposta sbagliata, perchè questa implementazione\nnon è bilanciata",
        "Il costo di lookupNode, insertNode e removeNode può essere O(2^n) in un caso particolare",
        "Risposta sbagliata, perchè costano O(h)\ndove h è l'altezza dell'albero"
      ]
    }
  },
  "Lezione RedBlack": {
    "DescrizioneLezione": "Ciao in questa lezione vedremo le operazioni base di un albero red black",
    "AlgoritmoInterattivo": "RB",
    "Pseudocodice": {
      "Tree rotateLeft(Tree x)": "Tree y = x.right\nTree p = x.parent\nx.right = y.left\nif (y.left != null)\n\ty.left.parent = x\ny.left = x\nx.parent = y\ny.parent = p\nif (p != null)\n\tif (p.left == x)\n\t\tp.left = y\n\telse\n\t\tp.right = y\nreturn y",
      "Tree rotateRight(Tree x)": "Tree y = x.left\nTree p = x.parent\nx.left = y.right\nif (y.right != null)\n\ty.right.parent = x\ny.right = x\nx.parent = y\ny.parent = p\nif (p != null)\n\tif (p.right == x)\n\t\tp.right = y\n\telse\n\t\tp.left = y\nreturn y",
      "Tree lookup(Tree t, Int j)": "while (t != null && t.key != j)\n\tif (j < t.key)\n\t\tt = t.left\n\telse\n\t\tt = t.right\nreturn t",
      "Void link(Tree p, Tree u, Int j)": "if (u != null)\n\tu.parent = p\nif (p != null)\n\tif (j < p.key)\n\t\tp.left = u\n\telse\n\t\tp.right = u",
      "Void insertNode(Tree t, Int j, Int v)": "Tree p = null\nTree u = t\nwhile(u != null && u.key != j)\n\tp = u\n\tif (j < u.key)\n\tu = u.left\nelse\n\tu = u.right\n\nif (u != null && u.key == j)\n\tu.value = v\nelse\n\tTree n = new Tree(j, v)\n\tlink(p,n,j)\n\tbalanceInsert(n)",
      "Void balanceInsert(Tree t)": "t.color = red\nwhile (t != null)\n\tTree p = t.parent\n\tTree n = (p != null)? p.parent : null\n\tTree z = (n == null)? null: (n.left == p)? n.right, n.left)\n\tif (p == null)\n\t\tt.color = black\n\t\tt = null\n\telse if (p.color == black)\n\t\tt = null\n\telse if (z.color == red)\n\t\tp.color = z.color = black\n\t\tn.color = red\n\t\tt = n\n\telse\n\t\tif (t == p.right && p == n.left)\n\t\t\trotateLeft(p)\n\t\t\tt = p\n\t\telse if (t == p.left && p == n.right)\n\t\t\trotateRight(p)\n\t\t\tt = p\n\t\telse\n\t\t\tif (t == p.left && p == n.left)\n\t\t\t\trotateRight(n)\n\t\t\telse if (p.right == t && p == n.right)\n\t\t\t\trotateLeft(n)\n\t\t\tp.color = black\n\t\t\tn.color = red\n\t\t\tt = null",
      "Tree removeNode(Int x, Tree r)": "Tree u = lookup(r,x)\nif (u != null)\n  if(u.left != null && u.right != null)\n    Tree s = u.right\n    while (s.left != null)\n      s = s.left\n    u.key = s.key\n    u.value = s.value\n    x = s.key\n    u = s\n\n   Tree t\n    if ( u.left != null && u.right == null)\n      t = u.left\n    else\n      t = u.right\n\n  link(u.parent, t, x)\n  if (u.color == black)\n    balanceDelete(r,t)\n  if (u.parent == null)\n    if (t != null)\n      t.parent = null\n    while (r.parent != null)\n      r = r.parent\n    return t\nreturn r",
      "Void balanceDelete(Tree T, Tree t)": "while (t != T && t.color == black)\n\tTree p = t.parent\n\tif (t == p.left)\n\t\tTree f = p.right\n\t\tTree ns = f.left\n\t\tTree nd = f.right\n\t\tif (f.color == red)\n\t\t\tp.color = red\n\t\t\tf.color = black\n\t\t\trotateLeft(p)\n\t\telse\n\t\t\tif (ns.color == nd.color == black)\n\t\t\t\tf.color = red\n\t\t\t\tt = p\n\t\t\telse if (ns.color == red && nd.color == black)\n\t\t\t\tns.color = black\n\t\t\t\tf.color = red\n\t\t\t\trotateRight(f)\n\t\t\telse if (nd.color == red)\n\t\t\t\tf.color = p.color\n\t\t\t\tp.color = black\n\t\t\t\tnd.color\n\t\t\t\trotateLeft(p)\n\t\t\t\tt = T\n\telse\n\t\tif (f.color == red)\n\t\t\tp.color = red\n\t\t\tf.color = black\n\t\t\trotateRight(p)\n\t\telse\n\t\t\tif (ns.color == nd.color == black)\n\t\t\t\tf.color = red\n\t\t\t\tt = p\n\t\t\telse if (ns.color == red && nd.color == black)\n\t\t\t\tns.color = black\n\t\t\t\tf.color = red\n\t\t\t\trotateLeft(f)\n\t\t\telse if (nd.color == red)\n\t\t\t\tf.color = p.color\n\t\t\t\tp.color = black\n\t\t\t\tnd.color\n\t\t\t\trotateRight(p)\n\t\t\t\tt = T\nif (t != null)\n\tt.color = black",
      "Tree min(Tree t)": "while (t.left != null)\n\tt = t.left\nreturn t",
      "Tree max(Tree t)": "while (t.right != null)\n\tt = t.right\nreturn t",
      "Tree successorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.right != null)\n\treturn t.right.min\n\nTree p = t.parent\nwhile (p != null && t == p.right)\n\tt=p\n\tp = p.parent\n\nreturn p",
      "Tree predecessorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.left != null)\n\treturn t.right.max\n\nTree p = t.parent\nwhile (p != null && t == p.left)\n\tt=p\n\tp = p.parent\n\nreturn p"
    },
    "DomandeRiposteSpiegazioni": {
      "Quale tra questi non è un vincolo che un Albero RB deve soddisfare?": [
        "Solo Il primo figlio inserito in un nodo rosso è nero",
        "Risposta corretta, perche' ogni nodo rosso\nha entrambi i figli neri",
        "La radice è nera",
        "Risposta sbagliata",
        "Tutte le foglie sono nere",
        "Risposta sbagliata"
      ],
      "Quale tra le seguenti è la definizione corretta di altezza nera?": [
        "Numero di nodi neri lungo ogni percorso da un nodo u (escluso) ad una foglia",
        "Risposta corretta",
        "Numero di nodi neri lungo ogni percorso da un nodo u (incluso) ad una foglia",
        "Risposta sbagliata, perchè u è escluso",
        "Numero di nodi neri lungo ogni percorso da un nodo u (escluso) ad una foglia con padre nero",
        "Risposta sbagliata, perchè il padre della\nfoglia può essere rosso"
      ],
      "Quale tra le seguenti operazioni richiedono di essere modificate rispetto agli ABR?": [
        "insertNode, removeNode",
        "Risposta corretta",
        "min, max, lookupNode",
        "Risposta sbagliata, perchè bisogna modificare\nsolamente insertNode e removeNode",
        "successorNode, predecessorNode",
        "Risposta sbagliata, perchè bisogna modificare\nsolamente insertNode e removeNode"
      ],
      "Qual è la complessità della procedura balanceInsert?": [
        "O(h), dove h è l'altezza dell'albero",
        "Risposta corretta",
        "O(n)",
        "Risposta sbagliata, perchè costa O(h) in\nquanto l'esecuzione di ognuno dei singoli\ncasi è O(1)",
        "O(2^n)",
        "Risposta sbagliata, perchè costa O(h) in\nquanto l'esecuzione di ognuno dei singoli\ncasi è O(1)"
      ],
      "Qual è la complessità della procedura removeNode?": [
        "O(log n)",
        "Risposta corretta",
        "O(n)",
        "Risposta sbagliata, perchè è possibile visitare al\nmassimo un numero O(log n) di casi, ognuno\ndei quali costa O(1)",
        "O(2^n)",
        "Risposta sbagliata, perchè è possibile visitare al\nmassimo un numero O(log n) di casi, ognuno\ndei quali costa O(1)"
      ]
    }
  }
}
