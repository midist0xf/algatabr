{
  "ABR": {
    "DescrizioneLezione": "Ciao in questa lezione vedremo le operazioni base di un albero binario di ricerca",
    "AlgoritmoInterattivo": "ABR",
    "Pseudocodice": {
      "Tree lookup(Tree t, Int j)": "while (t != null && t.key != j)\n\tif (j < t.key)\n\t\tt = t.left\n\telse\n\t\tt = t.right\nreturn t",
      "Void link(Tree p, Tree u, Int j)": "if (u != null)\n\tu.parent = p\nif (p != null)\n\tif (j < p.key)\n\t\tp.left = u\n\telse\n\t\tp.right = u",
      "Void insertNode(Tree t, Int j, Int v)": "Tree p = null\nTree u = t\nwhile(u != null && u.key != j)\n\tp = u\n\tif (j < u.key)\n\t\tu = u.left\n\telse\n\t\tu = u.right\n\nif (u != null && u.key == j)\n\tu.value = v\nelse\n\tTree n = new Tree(j, v)\n\tlink(p,n,j)",
      "Tree removeNode(Int x, Tree r)": "Tree u = lookup(r,x)\nif (u != null)\n   if(u.left != null && u.right != null)\n      Tree s = u.right\n      while (s.left != null)\n         s = s.left\n      u.key = s.key\n      u.value = s.value\n      x = s.key\n      u = s\n\n    Tree t\n    if (u.left != null && u.right == null)\n       t = u.left\n    else\n       t = u.right\n\n    link(u.parent, t, x)\n    if (u.parent == null)\n       if (t != null)\n          t.parent = null\n       return t\nreturn r",
      "Tree min(Tree t)": "while (t.left != null)\n\tt = t.left\nreturn t",
      "Tree max(Tree t)": "while (t.right != null)\n\tt = t.right\nreturn t",
      "Tree successorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.right != null)\n\treturn t.right.min\n\nTree p = t.parent\nwhile (p != null && t == p.right)\n\tt = p\n\tp = p.parent\n\nreturn p",
      "Tree predecessorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.left != null)\n\treturn t.right.max\n\nTree p = t.parent\nwhile (p != null && t == p.left)\n\tt = p\n\tp = p.parent\n\nreturn p"
    },
    "DomandeRiposteSpiegazioni": {
      "Cosa succede se inserisco un numero pari?": [
        "Hai inserito un numero pari",
        "Risposta corretta perche inserendo un numero pari ne hai inserito uno pari",
        "perdi 3% di bodyfat",
        "risposta sbagliata, se si perdesse il 3% di bodyfat inserendo numeri pari tutti avrebbero il sixpack",
        "niente",
        "risposta sbagliata, se inserisci qualcosa succede qualcosa"
      ],
      "Perche si chiamano abr?": [
        "perche e' l' acronimo",
        "Risposta corretta abr e' l'acronimo",
        "perche suonava bene",
        "risposta sbagliata, non e' vero",
        "c'era poca fantasia all'epoca",
        "no"
      ]
    }
  },
  "Lezione RedBlack": {
    "DescrizioneLezione": "Ciao in questa lezione vedremo le operazioni base di un albero red black",
    "AlgoritmoInterattivo": "RB",
    "Pseudocodice": {
      "Tree rotateLeft(Tree x)": "Tree y = x.right\nTree p = x.parent\nx.right = y.left\nif (y.left != null)\n\ty.left.parent = x\ny.left = x\nx.parent = y\ny.parent = p\nif (p != null)\n\tif (p.left == x)\n\t\tp.left = y\n\telse\n\t\tp.right = y\nreturn y",
      "Tree rotateRight(Tree x)": "Tree y = x.left\nTree p = x.parent\nx.left = y.right\nif (y.right != null)\n\ty.right.parent = x\ny.right = x\nx.parent = y\ny.parent = p\nif (p != null)\n\tif (p.right == x)\n\t\tp.right = y\n\telse\n\t\tp.left = y\nreturn y",
      "Tree lookup(Tree t, Int j)": "while (t != null && t.key != j)\n\tif (j < t.key)\n\t\tt = t.left\n\telse\n\t\tt = t.right\nreturn t",
      "Void link(Tree p, Tree u, Int j)": "if (u != null)\n\tu.parent = p\nif (p != null)\n\tif (j < p.key)\n\t\tp.left = u\n\telse\n\t\tp.right = u",
      "Void insertNode(Tree t, Int j, Int v)": "Tree p = null\nTree u = t\nwhile(u != null && u.key != j)\n\tp = u\n\tif (j < u.key)\n\tu = u.left\nelse\n\tu = u.right\n\nif (u != null && u.key == j)\n\tu.value = v\nelse\n\tTree n = new Tree(j, v)\n\tlink(p,n,j)\n\tbalanceInsert(n)\nwhile (n.parent != null)\n\tn = n.parent\nreturn n",
      "Void balanceInsert(Tree t)": "t.color = red\nwhile (t != null)\n\tTree p = t.parent\n\tTree n = (p != null)? p.parent : null\n\tTree z = (n == null)? null: (n.left == p)? n.right, n.left)\n\tif (p == null)\n\t\tt.color = black\n\t\tt = null\n\telse if (p.color == black)\n\t\tt = null\n\telse if (z.color == red)\n\t\tp.color = z.color = black\n\t\tn.color = red\n\t\tt = n\n\telse\n\t\tif (t == p.right && p == n.left)\n\t\t\trotateLeft(p)\n\t\t\tt = p\n\t\telse if (t == p.left && p == n.right)\n\t\t\trotateRight(p)\n\t\t\tt = p\n\t\telse\n\t\t\tif (t == p.left && p == n.left)\n\t\t\t\trotateRight(n)\n\t\t\telse if (p.right == t && p == n.right)\n\t\t\t\trotateLeft(n)\n\t\t\tp.color = black\n\t\t\tn.color = red\n\t\t\tt = null",
      "Tree removeNode(Int x, Tree r)": "Tree u = lookup(r,x)\nif (u != null)\n\tif(u.left != null && u.right != null)\n\t\tTree s = u.right\n\t\t\\while (s.left != null)\n\t\t\ts = s.left\n\t\tu.key = s.key\n\t\tu.value = s.value\n\t\tx = s.key\n\t\tu = s\n\n\t Tree t\n\t\tif ( u.left != null && u.right == null)\n\t\t\tt = u.left\n\t\telse\n\t\t\tt = u.right\n\n\t\tlink(u.parent, t, x)\n\tif (u.color == black)\n\t\tbalanceDelete(r,t)\n\t\tif (u.parent == null)\n\t\t\tif (t != null)\n\t\t\t\tt.parent = null\n\t\t\twhile (r.parent != null)\n\t\t\t\tr = r.parent\n\t\t\t\treturn t\nreturn r",
      "Void balanceDelete(Tree T, Tree t)": "while (t != T && t.color == black)\n\tTree p = t.parent\n\tif (t == p.left)\n\t\tTree f = p.right\n\t\tTree ns = f.left\n\t\tTree nd = f.right\n\t\tif (f.color == red)\n\t\t\tp.color = red\n\t\t\tf.color = black\n\t\t\trotateLeft(p)\n\t\telse\n\t\t\tif (ns.color == nd.color == black)\n\t\t\t\tf.color = red\n\t\t\t\tt = p\n\t\t\telse if (ns.color == red && nd.color == black)\n\t\t\t\tns.color = black\n\t\t\t\tf.color = red\n\t\t\t\trotateRight(f)\n\t\t\telse if (nd.color == red)\n\t\t\t\tf.color = p.color\n\t\t\t\tp.color = black\n\t\t\t\tnd.color\n\t\t\t\trotateLeft(p)\n\t\t\t\tt = T\n\telse\n\t\tif (f.color == red)\n\t\t\tp.color = red\n\t\t\tf.color = black\n\t\t\trotateRight(p)\n\t\telse\n\t\t\tif (ns.color == nd.color == black)\n\t\t\t\tf.color = red\n\t\t\t\tt = p\n\t\t\telse if (ns.color == red && nd.color == black)\n\t\t\t\tns.color = black\n\t\t\t\tf.color = red\n\t\t\t\trotateLeft(f)\n\t\t\telse if (nd.color == red)\n\t\t\t\tf.color = p.color\n\t\t\t\tp.color = black\n\t\t\t\tnd.color\n\t\t\t\trotateRight(p)\n\t\t\t\tt = T\nif (t != null)\n\tt.color = black",
      "Tree min(Tree t)": "while (t.left != null)\n\tt = t.left\nreturn t",
      "Tree max(Tree t)": "while (t.right != null)\n\tt = t.right\nreturn t",
      "Tree successorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.right != null)\n\treturn t.right.min\n\nTree p = t.parent\nwhile (p != null && t == p.right)\n\tt=p\n\tp = p.parent\n\nreturn p",
      "Tree predecessorNode(Tree t)": "if (t == null)\n\treturn t\n\nif (t.left != null)\n\treturn t.right.max\n\nTree p = t.parent\nwhile (p != null && t == p.left)\n\tt=p\n\tp = p.parent\n\nreturn p"
    },
    "DomandeRiposteSpiegazioni": {
      "P=NP?": [
        "No",
        "Risposta corretta perche' non e' possibile implementare la fortuna come codice",
        "Si",
        "risposta sbagliata, dimostralo se ci riesci",
        "dipende",
        "risposta sbagliata, siamo seri per favore"
      ],
      "Quanto e' difficile scrivere domande senza usare bestemmie?": [
        "tantissimo",
        "risposta giusta, sto quasi sudando per scrivere sta roba",
        "poco",
        "risposta sbagliata, riprova",
        "zero",
        "risposta sbagliata, e' piu facile laurearsi in corso con 110L"
      ]
    }
  }
}
